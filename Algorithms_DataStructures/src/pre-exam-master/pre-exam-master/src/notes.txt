-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------
	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes	Notes
-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------

-> Class that allow you to create dynamic Interface => java.lang.reflect.Proxy
    using Proxy.newProxyInstance() method


-> Design Pattern => Builder Pattern 


-> TCP/IP connection java = > socket class


-> how to speed search in MYSQL field's table  by make it (index)


-> Foreign key => referential integrity , one-to-many relationship , null

-> customer_id in purchase_order represent => forign key

-> Decorator pattern allows a user to add new functionality to an 
    existing object without altering its structure
	
-> Adapter pattern works as a bridge between two incompatible interfaces

-> Singleton pattern involves a single class which is responsible to create an object 
    while making sure that only single object gets created

-> Builder pattern builds a complex object using simple objects and using a step by step approach

-> DELETE Statement is used to delete rows from a table.
    DELETE FROM employee WHERE id = 100;

-> TRUNCATE is used to delete all the rows from the table and free the space containing the table.
    TRUNCATE TABLE employee;

-> DROP is used to remove table from the database or delete database
    1- DROP TABLE employee; 
    2- DROP DATABASE database_name;

-> for any boolean b
	boolean c = b ? !b : b;  
	c = false

-> exception(s) belongs to the J2SE API?
	1-ArrayIndexOutOfBoundsException
	2-NullPointerException

-> Complete the answer to make the following piece of code valid:

A a = new A();
A b = new B();


class A {}
class B extend A {}


-> JDBC RESULT SET

// result set take a query and return a set of rows 
ResultSet rs = stmt.executeQuery(query);
	
  while (resultSet.next()) {
     // Now we can fetch the data by column name, save	 and use    	 them!
   resultSet.getString("name");
}

Parent of any class -> Object

is http connection in java SE ? -> true

Parent of TreeSet -> SortedSet

is Garabge collector check the varables in  memory before run -> false

to use objectOutputStream --> the object must implements Serializable

to avoid sql Injection in java --> use PreparedStatement



-------------------------------------------


to sort any collection implement List ( ArrayList - LinkedList - Vector - Stack )

 ---> Collections.sort(al);

to search in any collection implement List ( ArrayList - LinkedList - Vector - Stack )

list must be sorted

 ---> Collections.binarySearch(list , key)


----------------------------------------------------------

to sory array -->



to search in array

  --> Arrays.binarysearch()





-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------
	*JAVA#	-JAVA-	#JAVA*	*JAVA#	-JAVA-	#JAVA*	*JAVA#	-JAVA-	#JAVA*	*JAVA#	-JAVA-	#JAVA*	*JAVA#	-JAVA-	#JAVA*
-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------


//AsciiArt

 https://www.codingame.com/ide/puzzle/ascii-art

by me:

public class Solution {

       public static void main(String args[]) {
           Scanner in = new Scanner(System.in);
           int L = in.nextInt();
           int H = in.nextInt();
           if (in.hasNextLine()) {
               in.nextLine();
           }
           String T = in.nextLine();
           T = T.toUpperCase();
           String res = "";
           for (int i = 0; i < H; i++) {
               String ROW = in.nextLine();
               for (int j = 0; j < T.length(); j++) {
                   int index = (T.charAt(j) - 'A');
                   int s = 0;
                   if(index > 25 || index < 0)
                       s = 26 * L;
                   else
                      s = index * L;
                   int e = s + L;
                   res += ROW.substring(s, e);
               }
               res += "\n";
           }
           System.out.println(res);
       }

}


@@@@@@ Another Sol @@@@@



static char scanChar(String s){
	if(s==null)return '?';
	for(char c = 'A';c<='Z';c++){
		String art = AsciiArt.printChar(c);
		if(s.equals(art)){
			return c;
		}
	}
	return '?';
}

-----------------------------------------

// Find longest sequence of zeros in binary representation of an integer.

// by me
    public static int solution2(int N) {
        String binaryString = Integer.toBinaryString(N);
        System.out.println(binaryString);
        char[] binaries = binaryString.toCharArray();

        boolean startedSequence = false;

        int currentLength = 0;
        int maxLength = 0;

        for (int x = 0; x < binaries.length; x++) {
            char bit = binaries[x];
            if (bit == '0') {
                if (x == binaries.length - 1) {
                    currentLength++;
                    if (maxLength < currentLength) {
                        maxLength = currentLength;
                        break;
                    }
                }
            if (startedSequence == false){
                startedSequence = true;
                currentLength = 1;
            }else{
                currentLength++;
            }
            }else if(bit == '1') {
                if(startedSequence == true){
                    startedSequence = false;
                    if(maxLength < currentLength) {
                        maxLength = currentLength;
                        currentLength = 0;
                    }
                }
            }
        }

        return maxLength;
  }



@@@@@@ Another Sol @@@@@



public int solution(int N) {
        String binaryString = Integer.toBinaryString(N);
        char[] binaries = binaryString.toCharArray();

        boolean startedSequence = false;

        int currentLength = -1;
        int maxLength = 0;

        for(char bit : binaries){
            if(bit == '0') {
                if(startedSequence){
                    currentLength ++;
                }
            }
            else if(bit == '1') {
                if(startedSequence == false) {
                    startedSequence = true;
                }
                else{
                    if(maxLength < currentLength){
                        maxLength = currentLength;
                    }
	}
                currentLength = 0;

            }
        }
        return maxLength;
}




------------------------------------------

// Rotate an array to the right by a given number of steps


@@@@@@ Another Sol @@@@@


 public int[] solution(int[] nums,int k) {
        
        int[] a = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            a[(i + k) % nums.length] = nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            nums[i] = a[i];
        }
        return nums;
}

--------------------------------------------

//closest To Zero Tempreture ( find The Tempreture )


// by me

class Solution {
    static double closestToZero(double[] ts) {
        double closest = 5527.0;
        if (ts.length == 0) {
            return 0;
        } else {
            for (int x = 0; x < ts.length; x++) {
                if (Math.abs(ts[x]) < Math.abs(closest)) {
                    closest = ts[x];
                } else if (Math.abs(ts[x]) == Math.abs(closest)) {
                    closest = Math.max(ts[x], closest);
                }
            }
            return closest;
        }
    }
}




@@@@@@ Another Sol @@@@@


double closestToZeroTempreture(double [] ts){
        
        double t_abs = Math.abs(ts[0]);
        double t_v = ts[0];
        
        for(int i=1;i<ts.length;i++){
            double c = Math.abs(ts[i]);
            if(c < t_abs){
                t_abs = c;
                t_v = ts[i];
            }
            else if(c == t_abs){
                if(t_v < ts[i]){
                    t_v = ts[i];
                }
            }
        }
        
        return t_v;    
}


-------------------------------------------

//stream printer

void print(Reader r) throws IOException{
        int c = r.read();
        while(c!=-1){
            System.out.print((char)c);
            c = r.read();
        }
        System.out.println("");
        r.close();
    }

------------------------------------------

// pi approximation


// pi approx

to get pi

π = ( area of circle / area of square ) * 4
so if we get ratio by random numbers we will get approxmation of PI
π = ( area of circle / area of square ) * 4


@@@@@@@@@ sol @@@@@@@@@@


double count = 1000000;
double success = 0;
double x, y;
for (int i = 0; i < count; i++) {
    x = Math.random();
    y = Math.random();
    success += x*x + y*y <= 1 ? 1 : 0;
}
double probability = success / count;
double PI = probability * 4;
System.out.println("Total: " + (int)count + "\nSuccess: " + (int)success);
System.out.println("PI = " + PI);


@@@@@@@@@ Another Sol @@@@@@@@


public static double approx(double[][] pts) {

    double totalSize = pts.length;
    double count = 0;
    for (int i = 0; i < totalSize; i++) {
        if (Math.pow(pts[i][0], 2) + Math.pow(pts[i][1], 2) <= 1) {
            count += 4;
        }
    }
    return count / totalSize;
}

public static void main(String[] args) {
    double[][] pts = new double[10000][2];
    for (int i = 0; i < 10000; i++) {
        pts[i][0] = Math.random();
        pts[i][1] = Math.random();
    }
    System.out.println(approx(pts));

}


--------------------------------------------


// chess competation how many pairs is posible

public  int count(int n){
        return   n*(n-1)/2;
    }

--------------------------------------------


//Pascale Triangle 
    
    public BigInteger fact(BigInteger n){
        BigInteger f = BigInteger.ONE;
        while(!n.equals(BigInteger.ZERO)){
            f = f.multiply(n);
            n = n.subtract(BigInteger.ONE);
        }
        return f;
    }
    
   public BigInteger NCR (BigInteger n , BigInteger k){
        return fact(n).divide(fact(n.subtract(k)).multiply(fact(k)));
    }
    
   public String NCR (int n , int k){
        return NCR(new BigInteger(n+"") , new BigInteger(k+""))+"";
    }
    

// OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR 

   public String get(int l, int c) {
        if (c > l - c) {
            c = l - c;
        }
        BigInteger b = BigInteger.ONE;
        for (int i = 1, m = l; i <= c; i++, m--)
            b = b.multiply(new BigInteger(m + "")).divide(new BigInteger(i + ""));
        
        return b.toString();
    }



@@@@ OR @@@@

static void printPascal(int n) {

    for (int line = 0; line < n; line++) {
        for (int i = 0; i <= line; i++)
            System.out.print(binomialCoeff
                    (line, i) + " ");

        System.out.println();
    }
}
static int binomialCoeff(int n, int k) {
    int res = 1;

    if (k > n - k)
        k = n - k;

    for (int i = 0; i < k; ++i) {
        res *= (n - i);
        res /= (i + 1);
    }
    return res;
}

public static void main(String args[]) {
    int n = 7;
    printPascal(n);
}


----------------------------------------------

// A.a(int i, int j) could return true if one of the argement equal 1 or if their sum equal to 1
   
static boolean a(int i, int j){
    return (i == 1) || (j == 1) || (i+j ==1);
}

----------------------------------------------

//update the code by implementing the following rules 

// if an exception throw by s.execute() then callc.rollback() then propagate the exception

// if any circumustance c.close() must be called before leaving the method a(service s, connection c)
    
void a(Service s, Connection c) throws Exception{
        s.setConnection(c);
        try{
            s.execute();
        }catch(Exception ex){
            c.rollback();
            c.close();
            throw ex;
        }
        c.commit();
        c.close();
    }
    
    interface Service {
        void execute() throws Exception;
        void setConnection(Connection c);
    }
    
    interface Connection {
        void commit();
        void rollback();
        void close();
    }

------------------------------------------------

Range sum
 
//solution.sumRange() shoud return the sum of the integers having the values between 10 to 100 inclusive and belong to the arra ints 
    
// fix issue 

    static int sumRange(int[] ints){
        int sum = 0;
        for(int i=0; i < ints.length; i++){  // change 1 to 0
            int number = ints[i];
            if (number >= 10 && number <= 100) sum += number;  // change || to &&
        }
        return sum;
    }

-------------------------------------------------

//algorithm.findLargest(int[] numbers) should return the largest number, array always contain at least one number 
    
static int findLargest(int[] number){
        if (number.length == 0) return 0;
        int largestNumber = number[0];
        for(int i=1 ; i<number.length ; i++){
            largestNumber = Math.max(largestNumber, number[i]);
        }
        return largestNumber;
}

-------------------------------------------------

//a tree composed of nodes
//a node holds a value correspoding to an integer
// implement a new node method named find which return the node holding the value of v

    class Node{
        
    Node left, right;
    int value;
    Node find(int v){
        Node curr = this;
        while (curr != null){
            if(curr.value == v) break;
            else if(v > curr.value) curr = curr.right;
            else curr = curr.left;
        }
        return curr;
      }   
    }

-----------------------------------------------------

//try to improve the code display in the answer editor by keeping the current behaviour of the program
    
abstract class Animal{
        String name;

        Animal(String name) {
            this.name = name;
        }
        String getName(){
            return name;
        }
    }
    
    
class Dog extends Animal{
        
        Dog(String name) {
            super(name);
        }
    }
    
    
class Cat extends Animal{
        
        Cat(String name) {
            super(name);
        }
    }
    
class Application {
        static String getAnimalName(Animal a){
            return a.getName();
        }
    }

--------------------------------------------------------------

// modify the body of some methods to protect person instances aginest alteration
    class person {
     
        private String name;
        private Date birthDate;
        
        public person(String name, Date birthDate){
            this.name = name;
            this.birthDate = (Date)birthDate.clone();
        }
        
        public String getName(){
            return name;
        }
        
        public Date getBirthDate(){
            return (Date) birthDate.clone();
        }
    
    }

-----------------------------------------------------------------

//calculator modify calculator.sum(String... number )
    static String sum(String... numbers){
        BigDecimal total = new BigDecimal("0");
        for(String number : numbers){
            total = total.add(new BigDecimal(number));
        }
        return total.toString();   
}     

//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR//OR

public class FloatingPoints {

    double sumNums(double [] t){
        return Double.valueOf(sumNumbers(t)+"");
    }
    
    BigDecimal sumNumbers(double [] t){
        if(t.length == 0)return BigDecimal.ZERO;
        BigDecimal sum = BigDecimal.ZERO;
        for(int i=0;i<t.length;i++){
            sum = sum.add(new BigDecimal(t[i]));
        }
        return sum;
    }
    
    public static void main(String [] args){
    
        FloatingPoints f = new FloatingPoints();
        double t []  = {1.0001,2.002,3.2154,123456.0000001};
        System.out.println(f.sumNums(t));
    }
}


-----------------------------------------------------------------

//water tankmonitor



class WaterTank {
    boolean empty;

    public boolean isEmpty() {
        return empty;
    }

    public void setEmpty(boolean empty) {
        this.empty = empty;
    }
}

class WaterTankMonitor {

    WaterTank tank;

    WaterTankMonitor(WaterTank tank) {
        this.tank = tank;
    }

    synchronized void empty() throws InterruptedException {
        while (tank.isEmpty()) {
            wait();
        }

        tank.setEmpty(true);
        notifyAll();
    }

    synchronized void fill() throws InterruptedException {
        while (!tank.isEmpty()) {
            wait();
        }

        tank.setEmpty(false);
        notifyAll();
    }
}



@@@@@@ Another Sol @@@@@@

class WaterTankMonitor {
        WaterTank tank;
        
        WaterTankMonitor (WaterTank tank){
            this.tank = tank;
        }
        
        void empty() throws InterruptedException{
            synchronized(tank){
                while(tank.isEmpty()){
                    try{
                        tank.wait();
                    }catch(InterruptedException ex){
                    }
                }
                tank.setEmpty(true);
                tank.notifyAll();
            }
        }
        
        synchronized void fill() throws InterruptedException{
            synchronized (tank){
                while(!tank.isEmpty()){
                    try{
                        tank.wait();
                    }catch(InterruptedException ex){}
                }
            }
                tank.setEmpty(false);
                tank.notifyAll();
        }
    }


--------------------------------------------------------------------------

// ([]) ([)]    praces

    
static boolean check (String str){
        if(str == null || str.length() == 0 ) return true;
        LinkedList<Character> li = new LinkedList<>();
        for(int i=0; i<str.length(); i++){
            if(isOpen(str.charAt(i))){
                li.addFirst(str.charAt(i));
            }else{
                if(li.isEmpty() || !matches(li.peekFirst(), str.charAt(i))) return false;
                li.removeFirst();
            }
        }
        return li.isEmpty();
    }
    
    private static boolean matches(char open, char close){
        return (open == '(' && close == ')') || (open == '[' && close == ']');
    }
    private static boolean isOpen(char c){
        return c == '(' || c== '[';
    }


//OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR   


boolean check (String s){
        if(s == null) return false;
        Stack<Character>stack = new Stack<>();
        for(int i=0;i<s.length();i++){
            switch(s.charAt(i)){
                case '{':
                    stack.add(s.charAt(i));
                    break;
                case '(':
                    stack.add(s.charAt(i));
                    break;
                case '[':
                    stack.add(s.charAt(i));
                    break;
                case '}':
                    if(stack.isEmpty() || stack.peek()!='{'){
                        return false;
                    }
                    stack.pop();
                    break;
                case ']':
                    if(stack.isEmpty() || stack.peek()!='['){
                        return false;
                    }
                    stack.pop();
                    break;
                case ')':
                    if(stack.isEmpty() || stack.peek()!='('){
                        return false;
                    }
                    stack.pop();
                    break;
                default:
                    //ignore
                    break;
            }
        }
        if(stack.empty()){
            return true;
        }
        return false;
    }

--------------------------------------------------------------------------------

The Dancer

//CairokeDancer 

int getPos(int v){
    if(v<0){return -1;}
    int pos [] =  {0,1,-1,-4,-5,-3};
    return pos [v%6] ;
}
    
//OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR OR   

int getPosition(int pos){
        if(pos == 0) return 0;
        int k = (pos-1) /3;
        int[] s = {1,-1,-4};
        int res = s[(pos-1)%3];
        if(k%2 == 1) res = -4-res;
        return res;
}

-----------------------------------------------------------------------------------

// Command factory problem ( Design Pattern )
    
	
class Program {
        String exec(String cmd, String text){
           CommandFactory commandFactory = new CommandFactory();
           Command command = commandFactory.getCommand(cmd);
           return command.exec(text);
        }
    }
    
class CommandFactory {
        public Command getCommand(String cmd){
            if(cmd.equals("CountWords")) return new CountWords();
            else throw new IllegalArgumentException(cmd);
        }
    }
    
    
interface Command {
        String exec(String text);
    }
    
    
class CountWords implements Command{

        @Override
        public String exec(String text) {
            return new WordCounter.count(text);
        }
        
    }
    
    
class ProgramTester {
        Program p;
        
        void init(){
            p = new Program();
        }
        
        void textCountWords(){
            String s = p.exec("CountWords", "Yes we code");
            assert (s.equals("J"));
        }
    }

----------------------------------------------------------------------

// buildermemory leak problem


class Stack_{
        private Object elements [];
    private int size = 0;

    public Stack_(int cap) {
        elements = new Object[cap];
    }
    
    public void push(Object o){
        if(size+1 < elements.length){
            elements[size++] = o;
        }
        else{
            Object temp [] = new Object[(size+1)*2];
            //System.arraycopy(elements, 0, temp, 0, size);
            for(int i=0;i<size;i++){
                temp [i] = elements[i];
                elements[i] = null;
            }
            temp[size++] = o;
            elements = temp;
        }
    }
    
    public Object pop(){
        if(size == 0){
            throw new StackOverflowError();
        }
        Object res = elements [size-1];
        elements [size-1] = null;
        size--;
        return res;
        
    }

}

-----------------------------------------------------------------

//binary search

import java.util.Arrays;



class A {


	static boolean exists(int[] ints, int k) {
        int index = Arrays.binarySearch(ints,k);

		if(index>=0){
			 return true;
		}


	return false;

	}

}

------------------------------------------------------------------

// files


import java.io.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class FileSystem {
    
    boolean writeToFileWithBuffer(String buffer , String filePath) {
        File f = new File(filePath);
        if(!f.exists()){
            return false;
        }
        Writer r;
        try {
            r = new FileWriter(f, true); //false for not append
            BufferedWriter writer = new BufferedWriter(r);
            writer.append(buffer);
            writer.close();
         } catch (IOException ex) {
            Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
        }
        return true;
    }
    
    boolean writeToFileWithWriter(String buffer , String filePath){
        File f = new File(filePath);
        if(!f.exists())return false;
        try {
            Writer writer = new FileWriter(f, true); //false for not append
            writer.write(buffer);
            writer.close();
        } catch (IOException ex) {
            Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
        }


    String readFromFileWithBuffer(String filePath){
        String res = "";
        File f = new File(filePath);
        if(!f.exists()){
            return null;
        }
        try {
            BufferedReader buffer = new BufferedReader(new FileReader(f));
            try {
                String cur = buffer.readLine();
                while(cur!=null){
                    res+=cur;
                    cur = buffer.readLine();
                    if(cur!=null){
                        res+="\n";
                    }
                }
            } catch (IOException ex) {
                Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return res;
    }
    String readFromFileWithReader(String filePath){
        String res = "";
        File f = new File(filePath);
        try {
            Reader reader = new FileReader(f);
            try {
                int c = reader.read();
                while(c>-1){
                    res+=(char)c;
                    c = reader.read();
                }
            } catch (IOException ex) {
                Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
        }
        return res;
    }
    String createFile(String fileName , String path){
        File f = new File(path+"\\"+fileName);
        try {
            return f.createNewFile()?  f.getPath() :  null;
        } catch (IOException ex) {
            Logger.getLogger(FileSystem.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
    
    public static void main(String args []){
        FileSystem fileSystem = new FileSystem();
        File f = new File("D:\\test");
        String filePath = fileSystem.getFilePath("New Text Document.txt", f);
        System.out.println(filePath);
        System.out.println(fileSystem.writeToFileWithBuffer("AHMED", filePath));
        System.out.println(fileSystem.writeToFileWithWriter("KOSHARY", filePath));
        System.out.println(fileSystem.readFromFileWithBuffer(filePath));
        System.out.println(fileSystem.readFromFileWithReader(filePath));
        System.out.println(fileSystem.createFile("createdFile.txt", "D:\\test"));
    }    
    
}

----------------------------------------------------------

class Echo {
	public static void main(String[] args) {
        int index = 0;
        int count = args.length;
        
        while(index < count) {
            System.out.println(args[index]);
            index++;
        }
        
        return;
	}
}

------------------------------------------------------------
//binary tree


class Node{
    int v;
    Node l , r;
    Node(int v){
    this.v = v;
    }
}

public class BinaryTree {
    private Node root;
    void insert(int v){
        Node n = new Node(v);
        if(root == null){
            root = n;
        }
        else{
            Node i = root;
            while(true){
                Node p = i;
                if(v < p.v){
                    i = p.l;
                    if(i==null){
                        p.l = n;
                        return ;
                    }
                }
                else{
                    i=p.r;
                    if(i==null){
                        p.r = n;
                        return;
                    }
                }
            }
        }
    }
    boolean search(int v){
        Node i = root;
        while(i!=null){
            if(i.v == v){
                return true;
            }
            else if (i.v > v){
                i = i.l;
            }
            else{
                i = i.r;
            }
        }
        return false;
        
    }
    private void print(Node n){
        if(n==null)return;
        System.out.print(n.v + " ");
        print(n.l);
        print(n.r);
    }
    void print(){
        print(root);
        System.out.println("");
    }
    int height(){
        if(root == null)return 0;
        else{
            return height(0 , root);
        }
    }
    private int height(int h , Node n){
        if(n == null)return h;
        h++;
        return Math.max(height(h , n.l), height(h, n.r));
        
    }
}

--------------------------------------------------------

// Complete the climbingLeaderboard function below.

static int[] climbingLeaderboard(int[] scores, int[] alice) {

    int i, sz1 = scores.length, sz2 = alice.length, idx=-1, j;
    List <Integer> sortedArray = new ArrayList();
    Arrays.sort(scores);
    int recent= scores[0];
    sortedArray.add(recent);
    for (i = 1; i < sz1; ++i) {
     if (recent != scores[i]){
      sortedArray.add(scores[i]);
     recent = scores[i];
     }
    }
  
    Comparator comptr = Collections.reverseOrder();
    Collections.sort(sortedArray, comptr);
  
    List <Integer> ret = new ArrayList<Integer>();
    int sortedArraySize = sortedArray.size();
    for (i = 0; i < sz2; ++i)
     {
         idx=-1;
         for (j=sortedArraySize-1; j>=0; --j){
             if (alice[i]<sortedArray.get(j))
             {
                 idx=j+2;
                 break;
             }
         }
         if (idx==-1)ret.add(1);
         else ret.add(idx);
     }
     int [] retArray = new int [ret.size()];
     for (i =0; i< ret.size(); ++i)
          retArray[i] = ret.get(i);
  
     return retArray;     
    }

/////////////////////////////////////////////////////////////////////  


static String timeConversion(String s) {
    String ret = s.substring(0, s.length()-2);
    int hoursInt = Integer.parseInt(s.substring(0,2));
    if (s.endsWith("PM") && hoursInt<12){
        String hours = Integer.toString(hoursInt+12);
        ret = hours+ret.substring(2);
    }
    else if (s.endsWith("AM") && hoursInt==12){
        ret = "00"+ret.substring(2);
    }
    return ret;
}


/////////////////////////////////////////////////////////////////////


static void plusMinus(int[] arr) {
    int i=0, len= arr.length;
    double pos=0, neg=0, zeros=0;

    for (i=0; i< len; ++i){
         if (arr[i]>0)pos++;
         else if (arr[i]<0)neg++;
         else zeros++;
    }
DecimalFormat df = new DecimalFormat("0.000000");
System.out.print(df.format(pos/len)+"\n"+df.format(neg/len)+"\n"+df.format(zeros/len)+"\n");
}
/////////////////////////////////////////////////////////////////////



-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------
	Design pattern	Design pattern	Design pattern	Design pattern	Design pattern	Design pattern	Design pattern
-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------

https://www.tutorialspoint.com/design_pattern/factory_pattern.htm

---------------------------------------------------

https://sourcemaking.com/design_patterns/decorator


--------------------------


Data Type	Default Value (for fields)
byte	0
short	0
int	0
long	0L
float	0.0f
double	0.0d
char	'\u0000'
String (or any object)  	null
boolean	false

--------------------------

byte: The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive).

short: The short data type is a 16-bit signed two's complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive).

int: By default, the int data type is a 32-bit signed two's complement integer, which has a minimum value of -231 and a maximum value of 231-1. 

long: The long data type is a 64-bit two's complement integer. The signed long has a minimum value of -263 and a maximum value of 263-1. 

float: The float data type is a single-precision 32-bit

double: The double data type is a double-precision 64-bit 

char: The char data type is a single 16-bit Unicode character.


----------------------------

SOLID principles of Object Oriented Design->>


https://www.javacodegeeks.com/2018/02/solid-principles-single-responsibility-principle.html


------------------------

\\ file finder


package JavaConcepts.Files;

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;

import static java.nio.file.FileVisitResult.*;
import static java.nio.file.FileVisitOption.*;

import java.util.*;


public class FileFinder {

    public static class Finder extends SimpleFileVisitor<Path> {

        private final PathMatcher matcher;
        private int numMatches = 0;

        Finder(String pattern) {
            matcher = FileSystems.getDefault().getPathMatcher("glob:" + pattern);
        }

        // Compares the glob pattern against
        // the file or directory name.
        void find(Path file) {
            Path name = file.getFileName();
            if (name != null && matcher.matches(name)) {
                numMatches++;
                System.out.println(file);
            }
        }

        // Prints the total number of
        // matches to standard out.
        void done() {
            System.out.println("Matched: " + numMatches);
        }

        // Invoke the pattern matching
        // method on each file.
        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
            find(file);
            return CONTINUE;
        }

        // Invoke the pattern matching
        // method on each directory.
        @Override
        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
            find(dir);
            return CONTINUE;
        }

        @Override
        public FileVisitResult visitFileFailed(Path file, IOException exc) {
            System.err.println(exc);
            return CONTINUE;
        }
    }

    static void usage() {
        System.err.println("java Find <path>" + " -name \"<glob_pattern>\"");
        System.exit(-1);
    }

    public static void main(String[] args) throws IOException {

//        if (args.length < 3 || !args[1].equals("-name"))
//            usage();
//        Path startingDir = Paths.get(args[0]);
//        String pattern = args[2];

        String pattern = "*.html";
        Path startingDir = Paths.get("..\\..");
        Finder finder = new Finder(pattern);
        Files.walkFileTree(startingDir, finder);
        finder.done();
    }
}

------------------------------------------------------------

Objectoutputstream .. Serialization


package JavaConcepts.ObjectOutputStream;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

class Persisit {
    public static void main(String args[]) throws Exception {
        Student s1 = new Student(211, "ravi");
        writeObject(s1);

        Student s2 = (Student) readObject();
        System.out.println(s2);

    }

    public static void writeObject(Object object) throws Exception  {
        if (object instanceof Serializable) {

            FileOutputStream fout = new FileOutputStream("f.txt" , true);
            ObjectOutputStream out = new ObjectOutputStream(fout);
            out.writeObject(object);
            out.flush();
            System.out.println("success");

        }else {
            System.out.println("not serialized");
        }

    }


    public static Object readObject() throws Exception {
        ObjectInputStream in=new ObjectInputStream(new FileInputStream("f.txt"));

        Object s= in.readObject();

        in.close();
        return s;
    }

    static class Student implements Serializable {
        int id;
        String name;
        public Student(int id, String name) {
            this.id = id;
            this.name = name;
        }


        @Override
        public String toString() {
            return "Student{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    '}';
        }
    }

}



-------------------------------------------------------------

BigInteger is immutable

BigInteger bint = new BigInteger("215");
bint.intValue();
bint.longValue();
bint.floatValue();
bint.doubleValue();

-----------------------------------------------------------

Equals method and hashcode

  For comparing two objects : We must Override

       Equals : works with
                1- equlas method
                2- ArrayList.contains

       hashcode method for :
                1- hashSet
                2- any hash collection
                cause they compares by hashcode !


REF : https://dzone.com/articles/working-with-hashcode-and-equals-in-java


------------------------------------------------


Collections


unique keys (key/value pairs):

    HashMap, LinkedHashMap, Hashtable , TreeMap


no duplicates :

    HashSet , LinkedHashSet , TreeSet


Sorted :

    TreeSet , TreeMap


allow duplicate elements

    LinkedList, ArrayList, Vector


========

Collections


1- SET

    Global:

    unique elements only.
    non synchronized


    1.1- HashSet

        stores using hashing.
        HashSet allows null value.
        HashSet doesn't maintain the insertion order. Here, elements are inserted on the basis of their hashcode.
        HashSet is the best approach for search operations.
        default capacity of HashSet is 16, and the load factor is 0.75.

    1.2- TreeSet ( impelements NavigableSet <<interface>> extends sortedSet <<interface>> )

        Java TreeSet class access and retrieval times are quiet fast.
        doesn't allow null element.
        maintains ascending order.

    1.3- LinkedHashSet

        permits null elements.
        maintains insertion order.


2- Map
    unique keys
    is non synchronized.


     2.1-HashMap

        contains values based on the key.
        contains only unique keys.
        may have one null key and multiple null values.
        maintains no order.
        default capacity of Java HashMap class is 16 with a load factor of 0.75.

     2.2-TreeMap ( impelements NavigableMap <<interface>> extends sortedMap <<interface>> )

        ((((cannot have a null key )))))) but can have multiple null values.
        contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
        contains only unique elements.
        maintains ascending order.


     2.3- LinkedHashMap

        Java LinkedHashMap may have one null key and multiple null values.
        Java LinkedHashMap is non synchronized.
        Java LinkedHashMap maintains insertion order.
        The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.



3- HashTable

    (((((((synchronized)))))))))
    class contains unique elements.
    doesn't allow null key or value.
    default capacity of Hashtable class is 11 whereas loadFactor is 0.75.
    A Hashtable is an array of a list. Each list is known as a bucket.
    The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.


--------------------------------------------

Types of Nested classes


1- Non-static nested class (inner class)
    -Member inner class
    -Anonymous inner class
    -Local inner class
2- Static nested class


-------------------------------------------


arraylist size --> .size()
hashset size -> .size()

-------------------------------

 java enum constants are
   - static and final implicitly.

 enum can have fields, constructors and methods

 enum.values() --> return array containg enum values


---------------------------------

Shift

~ (bitwise compliment) :  is Ones Complement Operator is unary and has the effect of 'flipping' bits.

10 -> -11

to make the number negative  ---->  ~x + 1

>> right shift operator :  remove from right

^ (bitwise XOR) : 1 with 1 -> 0  ,  1 with 0 -> 1

<< left shift operator : move bits to left and add 0 bits in right



-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------
	*SQL#	-SQL-	#SQL*	*SQL#	-SQL-	#SQL*	*SQL#	-SQL-	#SQL*	*SQL#	-SQL-	#SQL*	*SQL#	-SQL-	#SQL*
-------------------------------------------------------------------------------------------------------------------------------
*******************************************************************************************************************************
-------------------------------------------------------------------------------------------------------------------------------

//select destinct city order alphabatic

select disyinct city
from customer
order by city asc

-----------------------------------------

//query the product count per category name

select a.name as category_name , count(b.product_id) as product_count
from product_category a join product b
on
a.product_category_id = b.product_category_id
group by a.name

-----------------------------------------

//query the list number of customers per city

select city , count(*) as customer_count
from customer
group by city
having customer_count >= 2

-----------------------------------------

//query only the customers having purchased at least one product in books and garden order asc

select distinct a.customer_id

from purchase_order a , order_product b , product c , product_category d

where a.order_id = b.order_id and
b.product_id = c.product_id and
c.product_category_id = d.product_category_id
and
(d.name = 'Books' or d.name = 'Garden')

order by a.customer_id

-----------------------------------------

//select only the product having the heighest available stock

select product_id , name , available_stock  as heighest_available_stock
from product
where available_stock in (
	select max(available_stock)
	from product
)

-----------------------------------------

//select the number of purchase order per customer lastname

select a.lastname , count(b.customer_id) as purchase_order_count
from customer a join purchase_order b
on a.customer_id = b.customer_id
group by a.lastname
having purchase_order_count >= 2

-----------------------------------------

//select number of products per category name with 2 or more

select a.name as category_name , count(b.product_id) as product_count
from product_category a join product b on
a.product_category_id = b.product_category_id
group by a.name
having product_count >= 2

-----------------------------------------

//select only the customer not have purchase order

select customer_id , firstname , lastname
from customer
where customer_id not in (
	select distinct customer_id
	from purchase_order
)

-----------------------------------------

//list the customer who has the purchase order =75000 or 34000 and birth_date not null

select customer_id , firstname , lastname , zipcode
from customer
where (zipcode = '75000' or zipcode = '34000') and birth_date is not null

-----------------------------------------

//Select customer lastname and firstname who have the most purchased orders

select lastname , firstname
from customer
where customer_id in (

select a.customer_id
from customer a join purchase_order b on
a.customer_id = b.customer_id
group by a.customer_id
order by count(b.customer_id) desc
limit 1
)

-----------------------------------------

//select fname last name whose last name start with w

select firstname , lastname
from customer
where lastname like 'W%'
order by firstname

-----------------------------------------

//list all data where Category name = Books or = Garden

select a.firstname , a.lastname , d.name as product_name , e.name as category_name
from customer a , purchase_order b , order_product c , product d , product_category e
where a.customer_id = b.customer_id and
b.order_id = c.order_id and
c.product_id = d.product_id and
d.product_category_id = e.product_category_id and
(e.name = 'Books' or e.name = 'Garden')
order by a.firstname , a.lastname , d.name , e.name

----------------------------------------

//query product price > 100

select product_id , name , price

from product

where price > 100

order by price desc , product_id
----------------------------------------

//left join

select a.name as product_name , b.name as category_name
from product a left join product_category b on
a.product_category_id = b.product_category_id








